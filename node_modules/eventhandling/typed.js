// @flow

declare class FocusEvent extends UIEvent {
	target: EventTarget;
	relatedTarget: EventTarget;
	detail: number;
}

interface EventDetails {
	bubbles?: boolean;
	cancelable?: boolean;
	composed?: boolean;
}

interface MouseEventDetails extends EventDetails {
	target?: EventTarget;
	detail?: number;
	screenX?: number;
	screenY?: number;
	clientX?: number;
	clientY?: number;
	altKey?: boolean;
	ctrlKey?: boolean;
	shiftKey?: boolean;
	metaKey?: boolean;
	button?: 0|1|2;
}

interface TouchEventDetails extends EventDetails {
	touches?: TouchList;
	targetTouches?: TouchList;
	changedTouches?: TouchList;
	altKey?: boolean;
	metaKey?: boolean;
	ctrlKey?: boolean;
	shiftKey?: boolean;
}

interface FocusEventDetails extends EventDetails {
	target?: EventTarget;
	relatedTarget?: EventTarget;
	detail?: number;
}

interface WheelEventDetails extends MouseEventDetails {
	deltaX?: number;
	deltaY?: number;
	deltaZ?: number;
	deltaMode?: number;
}

interface KeyboardEventDetails extends EventDetails {
	target?: EventTarget;
	detail?: 0;
	key?: string;
	code?: string;
	altKey?: boolean;
	ctrlKey?: boolean;
	shiftKey?: boolean;
	metaKey?: boolean;
	repeat?: boolean;
	isComposing?: boolean;
}

const CustomEventConfig: EventDetails = {
	bubbles: true,
	cancelable: false
};

const MouseEventConfig: MouseEventDetails = {
	button: 0,
	bubbles: true,
	cancelable: false
};

const TouchEventConfig: TouchEventDetails = {
	bubbles: true,
	cancelable: false
};

const WheelEventConfig: WheelEventDetails = {
	button: 0,
	bubbles: true,
	cancelable: false
};

const FocusEventConfig: FocusEventDetails = {
	bubbles: true,
	cancelable: false
};


const KeyboardEventConfig: KeyboardEventDetails = {
	bubbles: true,
	cancelable: false
};

type MouseEventName = "click"|"dblclick"|"mousedown"|"mouseenter"|"mouseleave"|"mousemove"|"mouseout"|"mouseover"|"mouseup";
type WheelEventName = "wheel";
type KeyboardEventName = "keydown"|"keyup";
type FocusEventName = "blur"|"focus"|"focusin"|"focusout";
type TouchEventName = "touchstart"|"touchend"|"touchmove"|"touchcancel";

/**
* Fires an event.
* @param   {string}       eventName       - The event to fire.
* @param   {EventTarget}  [target=window] - The EventTarget to fire the event on.
* @param   {any}          [detail=null]   - The payload of the event.
* @param   {EventDetails} [config]        - The configuration of the event.
* @returns {CustomEvent}                    The created event.
*/
export function fire (eventName: string, target?: EventTarget = window, detail?: any = null, config?: EventDetails): CustomEvent {
	let normalizedConfig = Object.assign({}, CustomEventConfig, config || {}, {detail: detail || null});
	const event = new CustomEvent(eventName, normalizedConfig);
	target.dispatchEvent(event);
	return event;
}

/**
* Fires a MouseEvent.
* @param   {MouseEventName}    eventName       - The event name to fire.
* @param   {EventTarget}       [target=window] - The target to fire the event on.
* @param   {MouseEventDetails} [config]        - The configuration of the event.
* @returns {MouseEvent}                          The created event.
*/
export function fireMouseEvent (eventName: MouseEventName, target?: EventTarget = window, config?: MouseEventDetails): MouseEvent {
	let normalizedConfig = Object.assign({}, MouseEventConfig, config || {});
	const event = new MouseEvent(eventName, normalizedConfig);
	target.dispatchEvent(event);
	return event;
}

/**
* Fires a TouchEvent.
* @param   {TouchEventName}    eventName       - The event name to fire.
* @param   {EventTarget}       [target=window] - The target to fire the event on.
* @param   {TouchEventDetails} [config]        - The configuration of the event.
* @returns {TouchEvent}                          The created event.
*/
export function fireTouchEvent (eventName: TouchEventName, target?: EventTarget = window, config?: TouchEventDetails): TouchEvent {
	let normalizedConfig = Object.assign({}, TouchEventConfig, config || {});
	const event = new TouchEvent(eventName, normalizedConfig);
	target.dispatchEvent(event);
	return event;
}

/**
* Fires a WheelEvent.
* @param   {WheelEventName}    eventName       - The event name to fire.
* @param   {EventTarget}       [target=window] - The target to fire the event on.
* @param   {WheelEventDetails} [config]        - The configuration of the event.
* @returns {WheelEvent}                          The created event.
*/
export function fireWheelEvent (eventName: WheelEventName, target?: EventTarget = window, config?: WheelEventDetails): WheelEvent {
	let normalizedConfig = Object.assign({}, WheelEventConfig, config || {});
	const event = new WheelEvent(eventName, normalizedConfig);
	target.dispatchEvent(event);
	return event;
}

/**
* Fires a FocusEvent.
* @param   {FocusEventName}    eventName       - The event name to fire.
* @param   {EventTarget}       [target=window] - The target to fire the event on.
* @param   {FocusEventDetails} [config]        - The configuration of the event.
* @returns {FocusEvent}                          The created event.
*/
export function fireFocusEvent (eventName: FocusEventName, target?: EventTarget = window, config?: FocusEventDetails): FocusEvent {
	let normalizedConfig = Object.assign({}, FocusEventConfig, config || {});
	const event = new FocusEvent(eventName, normalizedConfig);
	target.dispatchEvent(event);
	return event;
}

/**
* Fires a KeyboardEvent.
* @param   {KeyboardEventName}    eventName       - The event name to fire.
* @param   {EventTarget}          [target=window] - The target to fire the event on.
* @param   {KeyboardEventDetails} config          - The configuration of the event.
* @returns {KeyboardEvent}                          The created event.
*/
export function fireKeyboardEvent (eventName: KeyboardEventName, target?: EventTarget = window, config: KeyboardEventDetails): KeyboardEvent {
	if (config == null || config.code == null) throw new ReferenceError(`You must provide a config object with a declared 'code' key!`);
	let normalizedConfig = Object.assign({}, KeyboardEventConfig, config);
	const event = new KeyboardEvent(eventName, normalizedConfig);
	target.dispatchEvent(event);
	return event;
}

/**
 * Returns a promise that resolves when the given event is fired on the target.
 * @param   {string}          eventName  - The event name to listen for.
 * @param   {EventTarget}     target     - The target to listen on.
 * @param   {Function}        [callback] - An optional function to call when the event is fired.
 * @returns {Promise<Event>}               A Promise that resolves with the event value when the event is fired on the target.
 */
export function waitUntilFired (eventName: string, target: EventTarget, callback?: Function): Promise<Event> {
	return new Promise(resolve => {
		const handler = function (e) {
			target.removeEventListener(eventName, handler);
			resolve(e);
			if (callback != null) callback(e);
		};
		target.addEventListener(eventName, handler);
	});
}

/**
 * Returns a promise that resolves when any of the given events fires for the first time.
 * @param   {string[]}       eventNames - The event names to listen for.
 * @param   {EventTarget}    target     - The target to listen on.
 * @param   {Function}       [callback] - An optional callback function to call when the first event is fired.
 * @returns {Promise<Event>}              A Promise that resolves with the event that fires first.
 */
export function waitUntilAnyIsFired (eventNames: string[], target: EventTarget, callback?: Function): Promise<Event> {
	return new Promise(resolve => {
		let resolved = false;
		eventNames.forEach(eventName => waitUntilFired(eventName, target).then(e => {
			if (resolved) return;
			resolved = true;
			resolve(e);
			if (callback != null) callback(e);
		}));
	});

}

/**
 * Returns a promise that resolves when the given event is fired on all the targets.
 * @param   {string}           eventName - The event name to listen for.
 * @param   {EventTarget[]}    targets   - The targets to listen on.
 * @returns {Promise<Event[]>}             A Promise that resolves with the values of the events when the event is fired on all the given targets.
 */
export function waitUntilFiredOnEach (eventName: string, targets: Array<EventTarget>): Promise<Event[]> {
	return Promise.all(targets.map(target => waitUntilFired(eventName, target)));
}